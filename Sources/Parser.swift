//
//  Parser.swift
//  compiler
//
//  Created by Jared Halpern
//

import Foundation

public enum ParseError: Error {
    case unexpectedToken(Token, String = "")
    case unexpectedTypeAnnotation(Token)
    case missingColon(Token)
    case missingSemicolon
    case missingTypename(String)
    case unexpectedAssignmentType(Token)
    case unknownError(String)
    case expectedIdentifier(Token)
    
    var message: String {
        switch self {
        case .unexpectedToken(let token, let message):
            return "Unexpected Token: \(token). \(message)"
        case .unexpectedTypeAnnotation(let token):
            return "Unexpected Type Annotation: \(token)"
        case .unexpectedAssignmentType(let token):
            return "Unexpected Assignment Type: \(token)"
        case .missingColon(let token):
            return "Missing colon. Got: \(token)"
        case .missingSemicolon:
            return "Missing semi-colon"
        case .missingTypename(let typeName):
            return "Missing type-name: \(typeName)"
        case .unknownError(let error):
            return "Unknown error: \(error)"
        case .expectedIdentifier(let token):
            return "Expected identifier. Got: \(token)"
        }
    }
}

/// A recursive-descent parser that produces an AST from `Token`s
public final class Parser {
    
    /// Tokens generated by the lexer
    private let tokens: [Token]
    /// Position in token stream
    private var pos = 0
    
    public private(set) var errors = [String]()
    
    public init(_ tokens: [Token]) {
        self.tokens = tokens
    }
    
    /// Parse tokens until reacing EOF. Initialize the parser with a given token list.
    /// - Returns: an array of Abstract Syntax Tree (AST) `Statement`s.
    public func parseProgram() -> [Statement] {
        
        var statements = [Statement]()
        
        while peek() != .eof {
            do {
                let statement = try parseStatement()
                statements.append(statement)
            } catch let error as ParseError {
                handleError(error)
                synchronize()
            } catch {
                handleError(.unknownError(error.localizedDescription))
                synchronize()
            }
        }
        return statements
    }
}

// MARK: - Private - Statement-Level Parsing

extension Parser {
    
    /// Handle various types of `Statement`s. Also checks for proper statement
    /// termination with a semicolon.
    /// - Returns: `Statement`
    private func parseStatement() throws -> Statement {
        
        switch peek() {
        case .printKw:                  // print statements
            return try parsePrint()
        case .varKw, .letKw:            // variable declaration (var keyword)
            return try parseVariableDeclaration()
        case .identifier where peekNext() == .equal: // x = 2
            return try parseAssignment()
        case .identifier:               // expression statements
            return try parseExpressionStatement()
        case .intLiteral, .lparen:      // expression statements
            return try parseExpressionStatement()
        case .funcKw:
            return try parseFunctionDeclaration()
        case .classKw:
            return try parseClassDecl()
            
        default:
            // Any other token is unexpected at statement level
            throw ParseError.unexpectedToken(peek())
        }
    }
}

// MARK: - Objects

extension Parser {
    
    private func parseClassDecl() throws -> ClassDecl {
        
        // consume classKw
        advance()
        
        guard case let .identifier(name) = peek() else {
            throw ParseError.expectedIdentifier(peek())
        }
        
        // consume name
        advance()
        
        guard peek() == .lbrace else {
            throw ParseError.unexpectedToken(peek(), "Expected left-parenthesis.")
        }
        
        // Consume lbrace
        advance()
        
        var members = [Statement]()
        
        while peek() != .rbrace && peek() != .eof {
            
            switch peek() {
            case .funcKw:
                let funcDecl = try parseFunctionDeclaration()
                members.append(funcDecl)
            case .varKw, .letKw:
                let varDecl = try parseVariableDeclaration()
                members.append(varDecl)
            default:
                // TODO: throw an error because we're unclear what this is.
                advance()
            }
        }
        guard peek() == .rbrace else {
            throw ParseError.unexpectedToken(peek(), "Expected right-brace.")
        }
        
        // consume rbrace
        advance()
        
        return ClassDecl(name: name,
                         statements: members)
    }
}

// MARK: - Functions

extension Parser {
    
    private func parseFunctionDeclaration() throws -> FuncDecl {
        
        // consume func()
        advance()
        
        guard case .identifier(let name) = advance() else {
            throw ParseError.unexpectedToken(peek(), "Expected identifier as function name.")
        }
        
        guard advance() == .lparen else {
            throw ParseError.unexpectedToken(peek(), "Expected left-parenthesis.")
        }
        
        var params: [(String, TypeAnnotation)] = []
        
        // Read function signature parameters
        while peek() != .rparen {
            
            guard case .identifier(let parameterName) = advance() else {
                throw ParseError.unexpectedToken(peek(), "Expected parameter name.")
            }
            
            guard case .colon = peek() else {
                throw ParseError.unexpectedToken(peek(), "Expected colon.")
            }

            // consume colon
            advance()

            let parameterType = try parseTypeAnnotation()
                        
            params.append((parameterName, parameterType))
            
            if peek() == .comma {
                advance()
            }
        }
        
        // While loop has ended so we know we are consuming a .rparen
        advance()
        
        // Optional: return type: `-> Type`
        var returnType: TypeAnnotation? = nil
        
        if peek() == .arrow {
            advance()
            returnType = try parseTypeAnnotation()
        }
        
        // Body
        guard advance() == .lbrace else {
            throw ParseError.unexpectedToken(peek())
        }
        
        var bodyStmts: [Statement] = []
        
        while peek() != .rbrace && peek() != .eof {
            bodyStmts.append(try parseStatement())
        }
        
        // consume '}'
        advance()
        
        return FuncDecl(name: name,
                        parameters: params,
                        returnType: returnType,
                        body: bodyStmts)
    }
}

// MARK: - Expression Parsing

extension Parser {
    
    /// Parse `x = <expr>;` assignments or fallback expression
    /// - Returns: desc
    private func parseAssignment() throws -> Statement {
        
        // We already know peek() is an .identifier. We're just grabbing the token here.
        guard case .identifier(let name) = peek() else {
            fatalError("parseAssignment: Expected identifier")
        }
        
        advance()
        
        // if peek reveals an equal then this is an assignment
        guard peek() == .equal else {
            fatalError("We accidentally sent an expression to the assignment function.")
        }
        
        advance()
        let value = try parseTerm()
        
        allowSemicolon()
        
        // return early
        return Assignment(name: name, value: value)
    }
    
    /// Parses a bare expression statement (e.g. `2 + 3;`)
    private func parseExpressionStatement() throws -> ExprStmt {
        // parse a full expression (with all +, *, parens, literals, identifiers, respecting precedence)
        let expr = try parseTerm()
        
        // Swallow the semicolon if present
        if peek() == .semicolon {
            advance()
        }
        return ExprStmt(expr: expr)
    }
    
    /// Handle multiplication, division, addition and subtraction, higher precedence atoms
    /// - Returns: Expression
    private func parseTerm() throws -> Expr {
        
        var expr = try parseFactor()
        
        // Handle left-associative + and -
        while peek() == .plus || peek() == .minus {
            
            let op = advance()
            let rhs = try parseFactor()
            
            expr = BinaryExpr(left: expr, op: op, right: rhs)
        }
        
        return expr
    }
    
    /// Parses multiplication and division (left-associative).
    private func parseFactor() throws -> Expr {
        
        // Parse the first atom
        var expr = try parseAtoms()
        
        // While next is * or /, consume and combine left-associatively
        while peek() == .star || peek() == .slash {
            let op = advance()
            let rhs = try parseAtoms()
            expr = BinaryExpr(left: expr, op: op, right: rhs)
        }
        
        return expr
    }
    
    /// Parses atoms: literals, identifiers, or parenthesized expressions.
    private func parseAtoms() throws -> Expr {
        
        switch peek() {

        case .stringLiteral(let str):
            advance() //?
            return StringLiteral(value: str)
            
        case .intLiteral(let v):
            advance()
            return IntLiteral(value: v)
            
        case .identifier(let name): // handle x = y
            advance()
            return IdentifierExpr(name: name)
            
        case .lparen:
            advance()
            let expr = try parseTerm() // throw the parsing back into the loop: term -> factor -> primary
            
            if peek() == .rparen {
                advance()
                return expr
            } else {
                throw ParseError.unexpectedToken(peek(), "Expected right-parenthesis.")
            }
            
        default:
            throw ParseError.unexpectedToken(peek())
        }
    }
}

// MARK: - Statement-specific helpers

extension Parser {
    
    /// Parse `print <expr>;` statements
    /// - Returns: `PrintStmt` `Statement`
    private func parsePrint() throws -> PrintStmt {
        advance()
        let expr = try parseTerm()
        allowSemicolon()
        return PrintStmt(expr: expr)
    }
    
    /// Parse 'var x[:Type] = <expr>;' declarations
    /// - Returns: desc
    private func parseVariableDeclaration() throws -> Statement {
        
        // consume var or let (variable)
        let assignmentType = advance()
        
        // Expect identifier for variable name
        guard case .identifier(let name) = peek() else {
            throw ParseError.unexpectedToken(peek())
        }
        
        // consume name of var
        advance()
        
        // Optional type annotation.
        var annotation: TypeAnnotation? = nil
        
        if peek() == .colon {
            advance()
            annotation = try parseTypeAnnotation()
        }
        
        guard peek() == .equal else {
            throw ParseError.unexpectedToken(peek(), "Expected equal sign in variable declaration")
        }
        
        // consume "="
        advance()
        
        let value = try parseTerm()
        
        // TODO: We don't support optionals yet so every initialized variable must be assigned a value
        // Consume optional semicolon
        allowSemicolon()
        
        if assignmentType == .letKw {
            return LetDecl(name: name, type: annotation, value: value)
        } else if assignmentType == .varKw {
            return VarDecl(name: name, type: annotation, value: value)
        } else {
            throw ParseError.unexpectedAssignmentType(assignmentType)
        }
    }
    
    /// Parse a type name after ':' (e.g. Bool, Int, String)
    private func parseTypeAnnotation() throws -> TypeAnnotation {
        
        guard case .typeKw(let name) = peek() else {
            throw ParseError.unexpectedToken(peek(),  "Expected type annotation.")
        }
        // consume .typeKw
        advance()
        
        switch name {
        case "Bool":
            return .bool
        case "String":
            return .string
        case "Int":
            return .int
        default:
            throw ParseError.unexpectedTypeAnnotation(.typeKw(name))
        }
    }
}

extension Parser {
    
    /// Swallow the semicolon if present
    private func allowSemicolon() {
        if peek() == .semicolon {
            advance()
        }
    }
    
    private func expectSemicolon() throws {
        guard peek() == .semicolon else {
            throw ParseError.missingSemicolon
        }
        advance()
    }
    
    private func expectColon() throws {
        guard peek() == .colon else {
            throw ParseError.missingColon(peek())
        }
        advance()
    }
    
    private func expectToken(_ expected: Token) throws {
        guard peek() == expected else {
            throw ParseError.unexpectedToken(peek(), "Expected: \(expected)")
        }
    }
}

extension Parser {
    /// Converts token values into readable symbols. Useful for debugging and printing error messages.
    /// - Parameter token: input `Token`
    /// - Returns: `String` value of that `Token`
    private func stringify(_ token: Token) -> String {
        switch token {
        case .plus: return "+"
        case .minus: return "-"
        case .star: return "*"
        case .slash: return "/"
        default: return ""
        }
    }
}

extension Parser {
    
    /// Returns current `Token` without moving forward
    /// - Returns: current `Token`
    private func peek() -> Token {
        return tokens[pos]
    }
    
    private func peekNext() -> Token {
        let next = pos + 1
        return next < tokens.count ? tokens[next] : .eof
    }
    
    /// Returns current `Token` and advances forward
    /// - Returns: current `Token`
    @discardableResult
    private func advance() -> Token {
        
        defer { pos += 1 }
        
        return tokens[pos]
    }
    
    /// Adds an error message.
    private func handleError(_ error: ParseError) {
        errors.append("Error: \(error)")
    }
    
    // Recover from parsing errors. Skip tokens until it finds a semicolon or EOF, preventing cascading failures.
    private func synchronize() {
        while peek() != .semicolon && peek() != .eof {
            advance()
        }
        if peek() == .semicolon { advance() }
    }
}
